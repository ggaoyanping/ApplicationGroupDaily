# finally
1.**作用**：定义一定执行的代码，通常用于关闭资源   
2.**异常在子父类覆盖中的体现**
- 子类在覆盖父类时，如果父类方法抛出异常，那么子类的覆盖方法只能抛出弗雷的异常或改异常的子类  
- 如果父类方法抛出多个异常，子类在覆盖该方法时，只能抛出父类异常的子集 
- 如果父类或者接口的方法中没有异常抛出，那么子类在覆盖方法时，也不可以抛异常，（如果子类方法发生了异常，就必须要进行try处理，绝对不能抛）  

3.**finally只有一种情况不会执行**——那就是遇到System.exit(0);  
4.**注意**：多个catch时，父类的catch要放在最下面
# 包的访问
1.**类的全名**：包名.类名

2.**包与包之间进行访问**：
- 被访问的包中的类以及类成员都需要public修饰  
- 不同包中的子类还可以访问父类中被protected权限修饰的成员
- 包与包之间可以使用的权限只有：public,protected
 
3.**导入包中的类**：import 包名.类名  
# 线程
1.**进程**：是一个正在执行中的程序。

2.**线程**：每一个进程执行都有一个执行顺序，该顺序是一个执行路径，或者叫控制单元，线程在控制着进程的执行  
3.**一个进程中至少有一个线程**：jvm启动的时候会有一个进程java.exe，该进程中至少有一个线程负责java程序执行，而且这个线程运行的代码存在于main方法中，该线程称为主线程  
4.**扩展**：jvm启动不止一个线程，还有负责垃圾回收机制的线程   
# 自定义线程的两种方式
一.**创建线程的第一种方式**——**继承Thread类**   

步骤    
- 1.定义类继承Thread
- 2.复写Thread中的run方法——目的是将自定义代码存储在run方法中，让线程运行
- 3.调用线程的start方法——该作用是启动线程，调用run方法  
- 
二.**创建线程的第二种方式**  ——**实现Runnable接口**

步骤     
- 1.定义类实现Runnable接口  
- 2.覆盖Runnable接口中的run方法，并将线程要运行的代码放在run中  
- 3.通过Thread建立线程对象  
- 4.将Runnable接口的子类对象作为实参传递给Thread类的构造函数  
- 5.调用Thread类的start()方法，开启线程，并调用Runnable接口子类的run方法   
 
三.**获取线程对象及名称**  

1.**默认名称**：Thread-编号，该编号从0开始  
2.**获取当前线程对象**：currentThread(),该方法是静态的    
3.**获取线程名称**：getName()  
4.**设置线程名称**：setName()或者构造函数

四.**多线程特性**——随机性(每次运行结果都不同) 




