# 多线程运行的安全问题
1.**原因**：当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没执行完，另一个线程参与进来执行，导致共享数据错误  
2.**方法**：同步代码块——对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不能执行  
3.**格式**：  
synchronize(任意唯一对象)   {
    需要被同步的代码;
}   
4.**对象如同锁**：只有持有锁的线程才可以在同步中执行  
5.**同步的前提**：  
- 1.必须是多线程  
- 2.必须是多个线程使用同一个锁  
 
6.**同步的好处**：解决了多线程的安全问题  
**同步的坏处**：多个线程都需要判断锁，较为消耗资源  
# 同步函数(锁是this)
一.**怎么判断需要同步的代码** 
- 1.明确哪些代码是多线程运行代码  
- 2.明确共享数据  
- 3.明确多线程运行代码中哪些语句是操作共享数据的 
 
二.**注意**： 

- 同步函数被静态修饰后使用的锁不是this，因为静态方法中不可以定义this    
- 静态进内存时，内存没有本类对象，但是一定有该类对应的字**节码文件对象**（**类名.class  该对象的类型是class**）  
- 静态的同步方法，使用的锁是该方法所在类的字节码文件对象 即  类名.class  
 
三.**死锁**——同步中嵌套同步，而锁却不同  
# 线程间通信 
1.**定义**：多个线程在操作同一个资源，但操作动作不用

二.**等待唤醒机制**：   
1.**为什么要将操作线程的方法定义在Object类中**：    
因为这些方法在操作同步线程时，都必须要标识他们所操作线程持有的锁，只有同一个锁上的被等待线程，才可以被同一个锁上的notify唤醒，也就是说等待，唤醒需要同一锁，而锁可以是任意对象，可以被任意对象调用的方法定义在Object中     
2.**注意**：  
- wait()方法是抛异常的，而他的父类Object没有抛出异常，所以调用wait方法只能马上try不能throw  
- 调用wait和notify必须要有当前线程的锁，即synchronize后面的对象， 调用时 对象.wait(),对象.notify()  
 
3.生产者和消费者都有两个或者两个以上，要将if改为while(while是每次都要判断条件)，if不用，并且将notify改为notifyAll  
4.**对于多个生产者和消费者，为什么要定义while判断标记**：   
因为要让被唤醒的线程再一次判断标记  
5.**为什么要定义notifyAll** :
因为需要唤醒对方线程。只用notify,容易出现只唤醒本方线程的情况，导致程序中的所有线程都等待  
# Lock接口
1.**Lock接口实现的类**有：ReentrantLock，通过ReentrantLock的对象可以创建锁 

2.**Lock接口中的方法有**：  
- void lock()——获取锁  
- void unlock()——释放锁  
- Condition newCondition()——返回一个Condition类 
 
3.Lock替代了synchronize方法和语句的使用，Condition代替了Object监视器方法(wait(),notify(),notifyAll())的使用

4.注意：**释放锁的动作一定要执行，所以lock.unlock()要放在finally中**

# Condition接口  
1.**该对象提供的方法**：  
- void await()——相当于wait(),处于等待状态  
- void signal()——相当于notify()，唤醒一个等待线程  
- void signalAll()——相当于notifyAll(),唤醒所有等待线程  
 
2.**注意**：创建Condition需要通过lock对象调用newCondition方法

